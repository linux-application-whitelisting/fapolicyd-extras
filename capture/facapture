#!/usr/bin/env python3
"""Capture fapolicyd debug output into a ring buffer and log on match."""

import argparse
import collections
import re
import subprocess
import sys
from typing import Deque, Iterable, Optional, TextIO
import os
import time

ANSI_ESCAPE_RE = re.compile(r"\x1B\[[0-?]*[ -/]*[@-~]")
READY_MARKER = "Starting to listen for events"


def strip_ansi(text: str) -> str:
    """Remove ANSI escape sequences from a string."""
    return ANSI_ESCAPE_RE.sub("", text)


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description=(
            "Capture fapolicyd debug output, buffer the last N lines, and "
            "write them to a file when a match occurs."
        )
    )
    parser.add_argument(
        "-n",
        "--buffer-size",
        dest="buffer_size",
        type=int,
        required=True,
        help="Ring buffer size to retain the last N lines.",
    )
    parser.add_argument(
        "-m",
        "--match",
        dest="match",
        type=str,
        required=True,
        help="String to match in the fapolicyd output (ANSI stripped).",
    )
    parser.add_argument(
        "output_file",
        type=str,
        help="File to write the buffered output to when a match occurs.",
    )
    parser.add_argument(
        "--keepalive",
        action="store_true",
        help=(
            "After capturing the match, keep draining piped input so the upstream "
            "process stays running."
        ),
    )
    return parser.parse_args()



def validate_buffer_size(size: int) -> None:
    """Ensure the ring buffer size is a positive integer."""
    if size <= 0:
        raise ValueError("Buffer size must be a positive integer")



def append_fapolicyd_state(path: str) -> None:
    """Append fapolicyd diagnostic information to the given file.

    This will:
    - trigger a state dump from the running fapolicyd daemon
    - append CPU/core information
    - append the contents of fapolicyd.state
    """
    cpu_cores = os.cpu_count()
    fapolicyd_version: Optional[str] = None
    # Try to obtain the fapolicyd version
    try:
        result = subprocess.run(
            ["fapolicyd", "--version"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            fapolicyd_version = result.stdout.strip()
    except Exception as exc:  # pragma: no cover - diagnostic only
        sys.stderr.write(
            f"[facapture] Warning: failed to query fapolicyd version: {exc}\n"
        )

    state_contents = ""
    # Trigger a fresh state dump if possible
    try:
        pid_result = subprocess.run(
            ["pidof", "fapolicyd"],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            timeout=2,
        )
        if pid_result.returncode == 0 and pid_result.stdout.strip():
            pid = pid_result.stdout.strip().split()[0]
            try:
                subprocess.run(
                    ["kill", "-USR1", pid],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    check=False,
                    timeout=2,
                )
                time.sleep(1)
            except Exception as exc:  # pragma: no cover - diagnostic only
                sys.stderr.write(
                    f"[facapture] Warning: failed to signal fapolicyd: {exc}\n"
                )
        # Read the state file regardless; it might already exist
        try:
            with open(
                "/var/run/fapolicyd/fapolicyd.state", "r", encoding="utf-8"
            ) as state_file:
                state_contents = state_file.read()
        except OSError as exc:  # pragma: no cover - diagnostic only
            sys.stderr.write(
                f"[facapture] Warning: failed to read fapolicyd.state: {exc}\n"
            )
    except Exception as exc:  # pragma: no cover - diagnostic only
        sys.stderr.write(
            f"[facapture] Warning: failed to obtain fapolicyd pid: {exc}\n"
        )

    try:
        with open(path, "a", encoding="utf-8") as output:
            output.write(" ===== environment =====\n")
            if cpu_cores is not None:
                output.write(f"CPU threads: {cpu_cores}\n")
            else:
                output.write("CPU threads: unknown\n")
            if fapolicyd_version:
                output.write(f"fapolicyd version: {fapolicyd_version}\n")
            output.write(" ===== fapolicyd.state =====\n")
            if state_contents:
                output.write(state_contents)
            else:
                output.write("(no fapolicyd.state content available)\n")
    except OSError as exc:  # pragma: no cover - diagnostic only
        sys.stderr.write(
            f"[facapture] Warning: failed to append fapolicyd state: {exc}\n"
        )



def write_buffer(buffer: Iterable[str], path: str) -> None:
    """Write the buffered lines to the specified file, then append diagnostics."""
    with open(path, "w", encoding="utf-8") as output:
        for line in buffer:
            output.write(line)
    # Best-effort append additional info; don't fail capture if this breaks.
    try:
        append_fapolicyd_state(path)
    except Exception as exc:  # pragma: no cover - diagnostic only
        sys.stderr.write(
            f"[facapture] Warning: unable to append fapolicyd diagnostics: {exc}\n"
        )



def terminate_process(proc: subprocess.Popen) -> None:
    """Terminate the subprocess cleanly, falling back to SIGKILL if needed."""
    if proc.poll() is not None:
        return
    try:
        proc.terminate()
        proc.wait(timeout=5)
    except subprocess.TimeoutExpired:
        proc.kill()
    except OSError:
        pass



def spawn_passthrough() -> None:
    """Launch a passthrough cat to keep the pipe open for the upstream."""
    try:
        subprocess.Popen(["cat"])
    except OSError as error:
        sys.stderr.write(f"[facapture] failed to keep stream open: {error}\n")


def capture_output(
    buffer_size: int,
    match: str,
    stream: Optional[Iterable[str]] = None,
    keepalive: bool = False,
) -> tuple[Deque[str], bool]:
    """Capture output from fapolicyd or stdin and look for a match.

    Args:
        buffer_size: Maximum number of lines to keep in the ring buffer.
        match: String to search for in stripped output.
        stream: Optional iterable of text lines. When omitted, facapture will
            execute ``fapolicyd --debug`` and capture its stdout.

    Returns:
        A tuple of (buffer, matched) where buffer is the deque of captured
        lines (from oldest to newest) and matched indicates whether the match
        was found.
    """
    ring: Deque[str] = collections.deque(maxlen=buffer_size)
    matched = False
    lines_after_match = 0
    ready_for_match = False
    handoff = False

    proc: Optional[subprocess.Popen[str]] = None
    source: Optional[Iterable[str]] = stream

    if source is None:
        proc = subprocess.Popen(
            ["fapolicyd", "--debug"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1,
        )
        source = proc.stdout

    try:
        if source is None:
            return ring, matched

        for raw_line in source:
            sys.stdout.write(raw_line)
            sys.stdout.flush()
            clean_line = strip_ansi(raw_line)
            if not (matched and lines_after_match == 0 and keepalive):
                ring.append(clean_line)

            if not ready_for_match:
                if READY_MARKER in clean_line:
                    ready_for_match = True
                continue

            if not matched and match in clean_line:
                matched = True
                lines_after_match = 2
                notify_line = clean_line.rstrip("\n")
                if notify_line:
                    sys.stdout.write(f"[facapture] match triggered: {notify_line}\n")
                else:
                    sys.stdout.write("[facapture] match triggered.\n")
                sys.stdout.flush()
                continue

            if matched and lines_after_match > 0:
                lines_after_match -= 1
                if lines_after_match == 0:
                    if keepalive:
                        handoff = True
                    break
        else:
            return ring, matched
    finally:
        if proc is not None:
            terminate_process(proc)

    if handoff:
        spawn_passthrough()

    return ring, matched



def main() -> int:
    """Entrypoint for facapture."""
    args = parse_args()
    try:
        validate_buffer_size(args.buffer_size)
    except ValueError as error:
        sys.stderr.write(f"error: {error}\n")
        return 1

    input_stream: Optional[TextIO] = None
    if not sys.stdin.isatty():
        input_stream = sys.stdin

    keepalive = bool(input_stream) and args.keepalive
    if args.keepalive and not keepalive:
        sys.stderr.write(
            "--keepalive ignored because no piped input was detected.\n"
        )

    buffer, matched = capture_output(
        args.buffer_size,
        args.match,
        input_stream,
        keepalive,
    )
    if not matched:
        sys.stderr.write("Match string not found before process exit.\n")
    try:
        write_buffer(buffer, args.output_file)
    except OSError as error:
        sys.stderr.write(f"Failed to write buffer: {error}\n")
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
